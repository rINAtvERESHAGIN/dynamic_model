from django.apps import apps
from django.http.request import HttpRequest
from django.http.response import HttpResponseBadRequest, JsonResponse, HttpResponse
from django.views import View
from django.conf import settings
from django.db.models.fields.related import ManyToManyField, ForeignKey, OneToOneField
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.status import HTTP_200_OK, HTTP_400_BAD_REQUEST
from .models import SendedSignal, ReceivedSignal
from .constants import CHECK_SIGNAL_TYPE
from rest_framework.permissions import AllowAny

#  Create your views here.

class ApiEndPointBaseView(View):
    _token = None
    required = []

    def check_post_data(self, request: HttpRequest):
        for field in self.required:
            if field not in request.POST:
                # print(field)
                return False
        return True

    def dispatch(self, request: HttpRequest, *args, **kwargs):
        if 'token' in request.POST:
            # print('{} here'.format(settings.API_TOKEN))
            # print('{} sended'.format(request.POST['token']))
            token = request.POST.get('token', None)
            # print(token == settings.API_TOKEN)
            if token == settings.API_TOKEN:
                self._token = token
                # print(self.check_post_data(request))
                if self.check_post_data(request):
                    # print('here')
                    return super().dispatch(request, *args, **kwargs)
        return HttpResponseBadRequest()


class ChoicesApiView(APIView):
    choices = None
    permission_classes = [AllowAny, ]

    def get_choices_data(self):
        result = []
        for choice in self.choices:
            result.append({'value': choice[0], 'text': choice[1]})
        return result

    def get(self, request, *args, **kwargs):
        data = self.get_choices_data()
        if len(data) > 0:
            return Response(data=data, status=HTTP_200_OK)
        else:
            return Response(data={'choices': 'No have data'}, status=HTTP_400_BAD_REQUEST)


class ChangeSignalStatus(ApiEndPointBaseView):
    required = [
        'uid',
        'error',
        'ended',
        'listeners_complete',
    ]

    def post(self, request: HttpRequest):
        uid = request.POST.get('uid')
        error = request.POST.get('error')
        ended = request.POST.get('ended')
        listeners_complete = request.POST.get('listeners_complete')
        signal = SendedSignal.objects.get(uid=uid)
        signal.is_ended = ended
        signal.is_error = error
        signal.listeners_complete = listeners_complete
        signal.save()
        return HttpResponse(status=HTTP_200_OK)


class ListenSignal(ApiEndPointBaseView):
    required = [
        'type',
        'sender',
        'uid',
        'signal',
    ]

    def post(self, request: HttpRequest):
        type = request.POST.get('type')
        sender = request.POST.get('sender')

        if sender not in settings.API_INSTANCE_DEPENDENCIES:
            return JsonResponse(data={
                'error': 'Dont have sender',
            })
        if type == CHECK_SIGNAL_TYPE:
            return JsonResponse(data={
                'success': 'True',
                'sender': sender,
            })

        uid = request.POST.get('uid')
        signal = request.POST.get('signal')
        # print(signal)

        received = ReceivedSignal.objects.get_or_create(
            sender=sender,
            type=type,
            object=uid,
            signal=signal
        )[0]
        if not received.is_success:
            result = received.execute()
            if result:
                received.is_success = True
                received.save()
        else:
            result = True
        return JsonResponse(data={
            'success': result,
            'sender': sender,
        })


class CallbackSignal(ApiEndPointBaseView):
    required = [
        'signal',
        'is_completed',
        'completed',
    ]

    def post(self, request: HttpRequest):
        uid = request.POST.get('signal')
        is_complete = request.POST.get('is_completed')
        completed = request.POST.get('completed')
        try:
            signal = SendedSignal.objects.get(uid=uid)
            signal.is_error = int(completed) != signal.listeners
            signal.is_ended = is_complete
            signal.listeners_complete = completed
            signal.save()
            result = True
        except SendedSignal.DoesNotExist:
            result = False
        return JsonResponse(data={
            'result': result
        })


class CheckObjectExistView(ApiEndPointBaseView):
    required = [
        'model', 'uid'
    ]

    def post(self, request: HttpRequest):
        uid = request.POST.get('uid')
        model = request.POST.get('model')
        app = None
        for key in settings.API_INSTANCE_MODELS.keys():
            if model in settings.API_INSTANCE_MODELS[key]:
               app = key
        exist = False
        if app is not None:
            Model = apps.get_model(app_label=app, model_name=model)
            try:
                Model.objects.get(uid=uid)
                exist = True
            except Model.DoesNotExist:
                exist = False
        return JsonResponse(data={
            'exist': exist
        })


class GetRelatedObjectView(ApiEndPointBaseView):
    required = [
        'model', 'uid', 'fields'
    ]

    def post(self, request: HttpRequest):
        uid = request.POST.get('uid')
        model = request.POST.get('model')
        fields = request.POST.getlist('fields')
        app = None
        for key in settings.API_INSTANCE_MODELS.keys():
            if model in settings.API_INSTANCE_MODELS[key]:
                app = key
        data = {}
        if app is not None:
            Model = apps.get_model(app_label=app, model_name=model)
            try:
                object = Model.objects.get(uid=uid).__dict__
                for field in fields:
                    value = object.get(field, None)
                    if value is not None:
                        if isinstance(value, ManyToManyField):
                            value = [i.pk for i in value.all()]
                        if isinstance(value, ForeignKey) or isinstance(value, OneToOneField):
                            value = value.pk
                        data[field] = value
            except Model.DoesNotExist:
                pass
        return JsonResponse(data=data)




