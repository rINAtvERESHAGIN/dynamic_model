from datetime import timedelta
from django.db import models
from django.conf import settings
from django.utils import timezone
from django.db.models import Model, Manager, BooleanField, DateTimeField, UUIDField
import uuid
from django.dispatch import receiver, Signal
from mscore.httpsignal import HttpSignal



class UUIDBaseModel(Model):
    '''
    @param uid: unique identifier to object
    '''
    uid = UUIDField(default=uuid.uuid4, editable=False)

    class Meta:
        abstract = True


class FreezeManager(Manager):
    def get_queryset(self):
        '''
        @:param self: object
        :return: queryset without freezed objetcts
        '''
        return super().get_queryset().exclude(is_freeze=True)

    def filter_freeze(self, **kwargs):
        return super().get_queryset().filter(**kwargs)


class FreezeBaseModel(UUIDBaseModel):
    is_freeze = BooleanField(default=False)  # 'Удалено, заблокировано'
    freeze = DateTimeField(blank=True, null=True, default=None)  # 'Дата заморозки'
    default_manager = Manager()
    objects = FreezeManager()

    class Meta:
        default_manager_name = 'default_manager'
        abstract = True

    def _check_if_in_settings(self):
        if self._meta.app_label not in settings.API_INSTANCE_MODELS:
            return False
        if self.__class__.__name__ not in settings.API_INSTANCE_MODELS[self._meta.app_label]:
            return False
        return True

    def _send_post_freeze(self):
        '''
        send post freeze signal
        :return: no return
        '''
        if self._check_if_in_settings():
            post_freeze.send(sender=self.__class__, instance=self)

    def _send_post_defreeze(self):
        '''
        send post unfreeze signal
        :return: no return
        '''
        if self._check_if_in_settings():
            post_defreeze.send(sender=self.__class__, instance=self)

    def _send_post_create(self):
        '''
        send post create signal
        :return: no return
        '''
        if self._check_if_in_settings():
            # print('here')
            post_create.send(sender=self.__class__, instance=self)

    def _provide_to_related(self, action, *args, **kwargs):
        '''
        get all related objects and freeze or unfreeze
        :param action: delete/save as string
        :param args: standart save/delete args
        :param kwargs: standart save/delete kwargs
        :return: no return
        '''
        for relation in self._meta._relation_tree:
            on_delete = getattr(relation.remote_field, 'on_delete', None)
            filter = {relation.name: self}
            related_queryset = relation.model.objects.filter(**filter)
            if action == 'delete':
                if on_delete == models.CASCADE:
                    for rel in related_queryset:
                        rel.delete()
                if on_delete == models.SET_NULL:
                    for rel in related_queryset:
                        rel.copy_and_freeze(*args, **kwargs)
                    related_queryset.update(**{relation.name: None})
            elif action == 'save':
                if on_delete == models.SET_NULL or on_delete == models.CASCADE:
                    for rel in related_queryset:
                        rel.defreeze(*args, **kwargs)

    def copy_and_freeze(self, *args, **kwargs):
        '''
        make copy self copy and freeze it
        :param args: standart save args
        :param kwargs: standart save kwargs
        :return: no return
        '''
        self.id = None
        self.is_freeze = True
        self.freeze = timezone.now().date()
        super().save(*args, **kwargs)

    def defreeze(self, *args, **kwargs):
        '''
        unfreeze self and all related objects
        :param args:
        :param kwargs:
        :return:
        '''
        self.is_freeze = False
        self.freeze = None
        super().save(*args, **kwargs)
        self._send_post_defreeze()

    def save(self, *args, **kwargs):
        # print('saved')
        is_create = False
        if self.pk is None:
            is_create = True
        if self.is_freeze:
            raise Exception('The object is frozen')
        if not self.is_freeze and self.freeze is not None:
            self.defreeze(*args, **kwargs)
            self._provide_to_related('save', *args, **kwargs)
        elif not self.is_freeze:
            super().save(*args, **kwargs)
        if is_create:
            self._send_post_create()

    def delete(self, force=False, *args, **kwargs):
        if force:
            return super().delete()
        if not self.is_freeze:
            self.is_freeze = True
            self.freeze = timezone.now().date()
            super().save(*args, **kwargs)
            self._provide_to_related('delete', *args, **kwargs)
            self._send_post_freeze()
        if self.is_freeze and self.freeze + timedelta(days=1460) == timezone.now().date():
            super().delete()

def is_approach_model(model):
    # print(model)
    # print(FreezeBaseModel)
    # print(issubclass(model, FreezeBaseModel))
    if not issubclass(model, FreezeBaseModel):
        return False
    if not issubclass(model, UUIDBaseModel):
        return False
    if model.__name__ not in settings.API_INSTANCE_MODELS[model._meta.app_label]:
        return False
    return True



post_freeze = Signal(providing_args=['instance'])
post_defreeze = Signal(providing_args=['instance'])
post_create = Signal(providing_args=['instance'])


@receiver(post_create)
def create_httpsignal(sender, instance, **kwargs):
    # print('create signal http')
    if is_approach_model(sender):
        # if created:
        # print('here')
        signal = HttpSignal(model_class=sender.__name__, uid=instance.uid)
        signal.send_create_signal()


@receiver(post_freeze)
def freeze_httpsignal(sender, instance, **kwargs):
    # print('freeze signal http')
    if is_approach_model(sender):
        signal = HttpSignal(model_class=sender.__name__, uid=instance.uid)
        signal.send_freeze_signal()


@receiver(post_defreeze)
def defreeze_httpsignal(sender, instance, **kwargs):
    # print('defreeze signal http')
    if is_approach_model(sender):
        signal = HttpSignal(model_class=sender.__name__, uid=instance.uid)
        signal.send_defreeze_signal()
